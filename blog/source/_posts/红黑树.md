---
title: 红黑树（C语言实现）
date: 2021-11-23 08:57:27
tags: tree
categories: 数据结构
top: 101
---

前面介绍了[二叉搜索树](https://iguochan.github.io/2021/11/21/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/)，其支持的搜索、插入和删除等操作，时间复杂度均为O(h)，h是树高。但是二叉搜索树对书的“平衡”没有要求，当其退化到近似链表结构后，树的高度比较高时，这些操作可能并不比在链表上快。

**红黑树（Red-Black Tree）**是平衡搜索树中的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为O(lg*n*)，*n*为节点个数。

以下介绍红黑树的C语言代码实现，[代码链接](https://github.com/IguoChan/data-structure/tree/main/tree)。

<!-- more -->

## 1 红黑树的性质
红黑树是一棵二叉搜索树，它的每个节点上增加了一个存储位来表示节点的颜色，可以是**红**或者**黑**。通过对一条从根到叶子的简单路径上各个节点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍，因而是**近似于平衡的**。

红黑树需要满足以下的**红黑性质**：

1. 每个节点或是红色的、或是黑色的；
2. 根节点是黑色的；
3. 每个叶子节点挂的两个空子节点是黑色的；
4. 如果一个节点是红色的，则它的两个子节点都是黑色的；
5. 对每个节点，从该节点到其所有的后代叶节点的简单路径上，均包含有相同数目的黑色节点。

* 注：有些教材将叶子节点挂的两个空子节点NIL视为叶节点，这里我们为了和之前的二叉搜索树保持一致，不采用此种描述。

**黑高**：从某个节点出发（不含该节点），到达任意一个叶节点的空子节点的简单路径上的黑色节点个数称为该节点的黑高。

**引理**: <font face="楷体" >一棵有n个节点的红黑树的高度至多为`2lg(n+1)`</font>

证明：

* 首先证明x为根的子树至少包含2<sup>bh(x)</sup>-1个内部节点。归纳法：	
	- 1.高度为0的节点x，其至少有0个内部节点；
	- 2.对于具有两个子节点的x，其子节点都有黑高bh(x)或bh(x)-1，分别取决于其自身是红色还是黑色；
	- 3.假设每个子节点有2<sup>bh(x)-1</sup>-1个内部节点；
	- 4.那么可以归纳出以x为根的子树至少包含(2<sup>bh(x)-1</sup>-1)+(2<sup>bh(x)-1</sup>-1)+1=2<sup>bh(x)</sup>-1个节点。
*  假设h为树的高度，根据性质4，从根节点到叶节点（不包含根节点）的任何一条简单路径上都至少包含有一般的节点为黑色；于是有n≥2<sup>h/2</sup>-1，从而得到h≤2lg(n+1)

* 根据引理，可知在红黑树上进行查找会在O(lg*n*)时间内执行。



## 2 插入

### 2.1 前期分析

对于红黑树的插入，其操作可以在O(log*n*)时间内完成。由于红黑树的插入和删除操作都比较复杂，需要用到旋转等操作保证红黑性质，所以我们相比于搜索二叉树新增了`parent`指针（当然没有这个指针也是可以实现的），当然，还有红黑树的节点着色，如下：
```c
typedef enum ColorType {RED, BLACK} ColorType;

typedef struct rbTreeNode {
    myElement data;
    struct rbTreeNode *parent;
    struct rbTreeNode *left;
    struct rbTreeNode *right;
    ColorType color;
} rbTreeNode_t;
```

针对树的NIL节点，我们新建一个`NilNode`节点，用作哨兵，我们将叶节点的左右子节点指向`NilNode`，也将根节点的父节点指向`NilNode`，当然，为了方便计，我们将`NilNode`的父节点和左右子节点都指向自身，其颜色被涂成黑色。如下：
```c
typedef struct rbTree {
    rbTreeNode_t *root;
} rbTree_t;

rbTreeNode_t *NilNode = NULL;

rbTree_t *rbtree_init()
{
    rbTree_t *T;

    if (!NilNode) {
        NilNode = malloc(sizeof(rbTreeNode_t));
        if (!NilNode) return NULL;
        NilNode->parent = NilNode->left = NilNode->right = NilNode;
        NilNode->color = BLACK;
        NilNode->data = INT_MAX;
    }

    T = malloc(sizeof(rbTree_t));
    if (!T) return NULL;
    T->root = NilNode;

    return T;
}
```

首先需要考虑的是，插入节点的颜色，如果插入的是黑色，那势必会破坏红黑性质5（除非是root节点），其它每一条线路上黑色节点个数都将小于插入的这一条，所以我们将插入节点着色为红色。

然后我们将插入节点插入到树T内，就好像T是一棵普通的二叉树那样，如下（请暂时忽略最后一行）：
``` c
void rbtree_insert(rbTree_t *T, myElement x)
{
    if (T == NULL) return;

    rbTreeNode_t *X = T->root;
    rbTreeNode_t *Y = NilNode;

    while (X != NilNode) {
        Y = X;
        if (x < X->data) X = X->left;
        else X = X->right;
    }


    rbTreeNode_t *Z = malloc(sizeof(rbTreeNode_t));
    if (!Z) return;
    Z->data = x;
    Z->parent = Y;
    Z->left = Z->right = NilNode;
    Z->color = RED;

    if (Y == NilNode) T->root = Z;
    else if (x < Y->data) Y->left = Z;
    else Y->right = Z;

    rbtree_insert_fixup(T, Z); // 暂时忽略
}
```
以上操作可以保证：

1. 性质1：插入的节点是红色的；
2. 性质3：Nil节点是黑色的；
3. 性质5：对每个节点，从该节点到其所有的后代叶节点的简单路径上，均包含有相同数目的黑色节点。

所以分析有以下情形：

* 如果插入的是根节点，那么破坏的是性质2，此时只需要将插入节点涂成黑色即可；
* 如果插入的不是根节点，那么性质2不可能被破坏，那么可能被破坏的只有性质4；
	- 如果插入节点的父节点是黑色的，那么性质4也不会被破坏，即插入后的红黑树依然满足红黑性质；
	- 如果插入节点的父节点是红色的，那么性质4即被破坏，那我们需要通过一系列的操作来使得插入后的红黑树依然满足红黑性质。



### 2.2 插入原则

所以我们总结插入的原则如下：

* 按照搜索树的特征插入；
* 插入时：插入节点涂成红色，进行以下判断：
	* 如果插入的是根节点，将颜色改成黑色；
	* 插入节点的父节点是黑色的，则插入完成；
	* 插入的节点的父节点是红色的，则需要修复，且继续向上调整，继续做判断，直到为根或满足条件；
	* 如果根修改之后为红色，则修改为黑色。


### 2.3 修复方法

针对以上分析需要修复的情况：插入节点的父节点是红色的，则其祖父节点一定是黑色的，否则插入前这棵树就不是一棵红黑树了。

定义父节点的兄弟节点为叔节点。

注：以下分析用到了以下两篇博客的图片：
[红黑树的插入操作过程详细图解](https://blog.csdn.net/jinking01/article/details/106020347)
[红黑树(二)之 C语言的实现](https://www.cnblogs.com/skywang12345/p/3624177.html)

#### 2.3.1 情况1：叔节点为红色

![情况1](/img/红黑树-情况1.png)

此时将插入节点的父节点和叔节点都涂成黑色，将其祖父节点涂成红色，并以其祖父节点为刚插入节点在此进行以上的判断。

此修复对于祖父节点以上的子节点而言，虽然新增了父节点和叔节点两个黑色节点，但是也删除了祖父节点这个黑色节点，所以在满足其性质4的情况下，其性质5并没有改变，如果接下来满足：1.祖父节点的父节点是黑色节点；2.祖父节点是根节点（将其涂黑）两条性质后，循环判断即可结束。如果祖父节点的父节点依然是红色节点，那么则继续以祖父节点为插入节点继续判断，可能出现的哈市情况1，当然也有可能是以下情况。

#### 2.3.2 情况2：叔节点为黑色，且插入节点和其父节点都是各自父节点的同侧

**都为左儿子**

![情况2-1](/img/红黑树-情况2-1.png)

此时将其父节点涂成黑色，将其祖父节点涂成红色并右旋。此操作得到的树一定满足性质4，也一定满足红黑树。

如果开始时其祖父节点是根节点，那么旋转后其父节点是根节点，且为黑色，则循环结束；如果开始是其祖父节点不是根节点，那么其祖父一定是黑色节点，旋转后，对于拥有这个子树的其曾祖父树而言，其没有改变任何一个枝干的黑色节点数，且其儿子节点的颜色没有改变，也不存在修改了性质4的点，同时因为其父节点涂黑，祖父节点涂红的操作，保证了祖父节点树的性质4，所以这棵数也是红黑树。

**都为右儿子**

![情况2-2](/img/红黑树-情况2-2.png)

这种情况是上一种情况的镜像，只需要将其祖父节点进行左旋就好了。

#### 2.3.3 情况3：叔节点为黑色，且插入节点和其父节点都是各自父节点的异侧

**插入节点为右儿子，父节点为左儿子**
![情况3-1](/img/红黑树-情况3-1.png)

将其父节点左旋后以其父节点为插入节点继续判断。很明显可以看出，以其父节点左旋以后，父节点变为子节点，子节点变为父节点，情况变成了情况2中都为左儿子的情形。

**插入节点为左儿子，父节点为右儿子**

![情况3-2](/img/红黑树-情况3-2.png)

上一种情况的镜像情况，不详细展开了。

### 2.4 旋转

#### 2.4.1 左旋
以上用到了旋转，左旋操作如下所示：
![左旋](/img/红黑树-左旋.jpg)

代码实现如下：
```c
void rbtree_left_rotate(rbTree_t *T, rbTreeNode_t *x)
{
    rbTreeNode_t *y = x->right;

    // y的左子树移植为x的右子树
    x->right = y->left;
    if (y->left != NilNode) y->left->parent = x;

    // x的父节点移植为y的父节点
    y->parent = x->parent;
    if (x->parent == NilNode) T->root = y;
    else if (x == x->parent->left) x->parent->left = y;
    else x->parent->right = y;

    // x移植为y的左子树
    y->left = x;
    x->parent = y;
}
```

#### 2.4.2 右旋

右旋操作如下所示：
![右旋](/img/红黑树-右旋.jpg)

代码实现如下：
```c
void rbtree_right_rotate(rbTree_t *T, rbTreeNode_t *y)
{
    rbTreeNode_t *x = y->left;

    // x的右子树移植为y的左子树
    y->left = x->right;
    if (x->right != NilNode) x->right->parent = y;

    // y的父节点一直为x的父节点
    x->parent = y->parent;
    if (y->parent == NilNode) T->root = x;
    else if (y == y->parent->left) y->parent->left = x;
    else y->parent->right = x;

    // y移植为x的右子树
    x->right = y;
    y->parent = x;
}
```


### 2.5 插入再平衡的代码实现

以上分析的代码实现如下，对于以上三种情况，首先是根据父节点是祖父节点的左儿子还是右儿子进行分类，下面基本是上面的镜像情况。

```c
void rbtree_insert_fixup(rbTree_t *T, rbTreeNode_t *node)
{
    rbTreeNode_t *uncle;

    // 如果其父节点是红色的，那么就不满足性质4，我们需要对其进行重新涂色
    // 如果parent是红色的，那么其一定有parent->parent
    while (node->parent->color == RED) {
        // 如果其父节点是其祖父节点的左儿子
        if (node->parent == node->parent->parent->left) {
            uncle = node->parent->parent->right;
            // 如果其叔节点是红色
            if (uncle->color == RED) {
                // case1
                node->parent->color = BLACK;// 将其父节点涂黑
                uncle->color = BLACK;       // 将其叔节点涂黑
                node->parent->parent->color = RED; // 将其祖父节点涂红
                node = node->parent->parent;// 利用其祖父节点作为循环量继续循环
            } else if (node == node->parent->right) {
                // case2
                node = node->parent;
                rbtree_left_rotate(T, node);
            } else {
                // case3
                node->parent->color = BLACK;
                node->parent->parent->color = RED;
                rbtree_right_rotate(T, node->parent->parent);
            }
        } else {
            uncle = node->parent->parent->left;
            // 如果其叔节点是红色
            if (uncle->color == RED) {
                node->parent->color = BLACK;
                uncle->color = BLACK;
                node->parent->parent->color = RED;
                node = node->parent->parent;
            } else if (node == node->parent->left) {
                node = node->parent;
                rbtree_right_rotate(T, node);
            } else {
                node->parent->color = BLACK;
                node->parent->parent->color = RED;
                rbtree_left_rotate(T, node->parent->parent);
            }
        }
    }
    T->root->color = BLACK;
}
```

插入的分析基本如上，根据[《数据结构与算法分析-C语言描述》](https://github.com/7-sevens/Developer-Books/blob/master/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf)的红黑树的例子，一次插入`10,85,15,70,20,60,30,50,65,80,90,40,5,55`的红黑树如下所示（红色节点用双圆圈表示）。

![红黑树-例子](/img/红黑树-例子.png)

而以上实现代码打印的红黑树如下，和图片是一致的。
```bash
30[B]
15[B]  70[B]
10[B]  20[B]  60[R]  85[B]
5[R]  NULL  NULL  NULL  50[B]  65[B]  80[R]  90[R]
NULL  NULL  NULL  NULL  NULL  NULL  NULL  NULL  40[R]  55[R]  NULL  NULL  NULL  NULL  NULL  NULL
```

### 2.6 分析
由于一棵有n个节点的红黑树高度为O(lg*n*)，因此常规插入的时间是O(lg*n*)，而rbtree_insert_fixup中，仅当情况1发生时，插入节点沿着树上升两层，while循环才会继续，直至出现情况2、3或者父节点为黑，所以其总次数也是O(lg*n*)；只要出现情况2，那么这一步必然是最后一步；只要出现情况3，那么必然一次处理就能到情况2，所以该程序所作的旋转最多是2次。

**通过以上分析，红黑树的插入最坏情况为O(lg*n*)。**

## 3 查询操作
红黑树是一种搜索二叉树，所以其查询和二叉树没有什么本质区别，所以接下来就只给出代码。

### 3.1 查找特定值的节点
``` c
rbTreePos_t *rbtree_search1(rbTreeNode_t *node, myElement x)
{
    if (node == NilNode) return NULL;

    if (x == node->data) return node;

    if (x < node->data) return rbtree_search1(node->left, x);
    else return rbtree_search1(node->right, x);
}

rbTreePos_t *rbtree_search(rbTree_t *T, myElement x)
{
    if (T == NULL) return NULL;

    return rbtree_search1(T->root, x);
}
```

### 3.2 查找最大值
```c
rbTreePos_t *rbtree_max1(rbTreeNode_t *node)
{
    if (node == NilNode) return NULL;

    rbTreePos_t *min = node;
    while (min->right != NilNode)
    {
        min = min->right;
    }
    return min;
}

rbTreePos_t *rbtree_max(rbTree_t *T)
{
    if (T == NULL) return NULL;

    return rbtree_max1(T->root);
}
```

### 3.3 查找最小值
```c
rbTreePos_t *rbtree_min1(rbTreeNode_t *node)
{
    if (node == NilNode) return NULL;

    rbTreePos_t *min = node;
    while (min->left != NilNode)
    {
        min = min->left;
    }
    return min;
}

rbTreePos_t *rbtree_min(rbTree_t *T)
{
    if (T == NULL) return NULL;

    return rbtree_min1(T->root);
}
```

## 4 删除

红黑树的删除分为两部分，一是查找到删除节点并删除，二是删除之后的自平衡。

### 4.1 删除节点

和搜索二叉树的删除一样，红黑树的删除操作如下所示，基本就是：


1. 当该节点没有儿子，即为树叶时，直接删除该节点即可；
2. 当该节点只有一个儿子时，直接用该孩子节点替换该节点即可；
3. 当该节点有两个儿子时，用其右子树最小节点数据代替该节点数据，并删除那个最小节点。而右子树的最小节点不可能有左儿子，所以删除右子树只会出现以上1、2两种情况。

但是有一点区别就是，需要记住真正被删除节点的颜色，并记住顶替被删除节点的节点，这是因为后续进行再平衡时需要，基本代码如下（暂时忽略current和rbtree_delete_fixup等）：
``` c
void rbtree_transplant(rbTree_t *T, rbTreeNode_t *u, rbTreeNode_t *v)
{
    if (u->parent == NilNode) T->root = v;
    else if (u == u->parent->left) u->parent->left = v;
    else u->parent->right = v;
    v->parent = u->parent;
}

void rbtree_delete1(rbTree_t *T, rbTreeNode_t *node, myElement x)
{
    if (node == NilNode) return;

    rbTreeNode_t *current;
    rbTreeNode_t *tmp;

    if (x < node->data) return rbtree_delete1(T, node->left, x);
    else if (x > node->data) return rbtree_delete1(T, node->right, x);
    // 以下两种情况都是 x == node->data
    else if (node->left != NilNode && node->right != NilNode) {
        // 两个儿子
        tmp = rbtree_min1(node->right);
        node->data = tmp->data;
        return rbtree_delete1(T, node->right, tmp->data);
    } else {
        tmp = node;
        // 如果没有左儿子，则将右儿子代替node，不管右儿子是不是NilNode
        if (node->left == NilNode) {
            current = node->right;
            rbtree_transplant(T, node, node->right);
        }
        else if (node->right == NilNode) {
            current = node->left;
            rbtree_transplant(T, node, node->left);
        }
    }

    if (tmp->color == BLACK) {
        rbtree_delete_fixup(T, current);
    }
    free(tmp);
}

void rbtree_delete(rbTree_t *T, myElement x)
{
    if (T == NULL) return;

    return rbtree_delete1(T, T->root, x);
}
```

### 4.2 再平衡

分析有：
1. 若真实删除的节点（若删除节点有两个子节点，删除的是其后继节点，或者也可以说是替换节点）是红色节点，那么红黑树的任何一条性质没有改变，无需做任何修改。
2. 若真实删除的节点是黑色节点，则至少破坏了性质5，因此需要进行修复。

所以我们的修复方案是记住真实被删除节点的颜色（使用tmp的颜色）和代替其位置的节点（current），然后依此进行判断。这个时候将节点current（也就是图中的current，图片借鉴[红黑树原理 新增，删除，打印](https://www.cnblogs.com/hongdada/p/12165636.html)）看成是双重颜色：双黑色（origin和被删除的节点都是黑色），红黑色（current是红色的，但是被删除节点是黑色的）。需要修正的情况有以下4种case。以下情况都是代替节点是其父节点左儿子的情况，若是右儿子，则情况是镜像的。循环条件就是代替节点current不是根节点且其颜色是黑色的，如果是红色或者根节点，直接涂黑就好了。循环操作的目标是将额外的黑色性质上移，循环开始的节点首先就是current，其后处理可能会变。

![红黑树-4case](/img/红黑树-4case.png)


#### 4.2.1 case1
这时候左子树中黑色节点减少一个，说明是无法满足性质5的，所以我们做出如下变化，此时并没有更改current的内存位置，不过其兄弟节点必然变成黑色，也就变成了case2/3/4中的一个。但是此时左右子树的黑高并没有改变，所以还是需要进行变换。

![红黑树-case1](/img/红黑树-case1.png)

#### 4.2.2 case2

case2的时候，当x的兄弟节点是黑色的，并且兄弟节点的左右子节点都是黑色的，那么将兄弟节点置为红色节点，并将循环节点置为其父节点。当其父节点是红色时，循环结束，最后将其父节点涂黑即可。若其父节点依然是黑色的，那么继续操作即可。

![红黑树-case1](/img/红黑树-case2.png)

#### 4.2.3 case3

case3时，处理如下，能将case3直接转换为case4。

![红黑树-case1](/img/红黑树-case3.png)

#### 4.2.4 case4

case4时，通过对某些颜色的修改，并对循环操作节点的父节点做依次左旋，可以去掉循环节点的额外黑色，此时红黑树重新满足红黑性质，无需再变化。为了推出循环，将循环指针指向根节点。

![红黑树-case1](/img/红黑树-case4.png)

### 4.3 分析

不进行再平衡时，红黑树的删除操作时间是O(lg*n*)。再平衡中，情况1、3、4在各执行常数次数的颜色改变和至多三次旋转后便终止，情况2的循环是唯一可能重复执行的，每次指针都沿着树上升，至多O(lg*n*)次，且无任何旋转。所以整个删除操作的总时间为O(lg*n*)。

### 4.4 代码实现
``` c
void rbtree_delete_fixup(rbTree_t *T, rbTreeNode_t *node)
{
    rbTreeNode_t *w;
    while(node != T->root && node->color == BLACK) {
        if (node == node->parent->left) {
            w = node->parent->right;
            if (w->color == RED) {
                // case1
                w->color = BLACK;
                node->parent->color = RED;
                rbtree_left_rotate(T, node->parent);
                w = node->parent->right;
            }
            if (w->left->color == BLACK && w->right->color == BLACK) {
                // case2
                w->color = RED;
                node = node->parent;
            } else if (w->right->color == BLACK) {
                // case3
                w->left->color = BLACK;
                w->color = RED;
                rbtree_right_rotate(T, w);
                w = node->parent->right;
            } else {
                // case4
                w->color = node->parent->color;
                node->parent->color = BLACK;
                w->right->color = BLACK;
                rbtree_left_rotate(T, node->parent);
                node = T->root;
            }
        } else if (node == node->parent->right) {
            // 镜像
            w = node->parent->left;
            if (w->color == RED) {
                // case1
                w->color = BLACK;
                node->parent->color = RED;
                rbtree_right_rotate(T, node->parent);
                w = node->parent->left;
            }
            if (w->left->color == BLACK && w->right->color == BLACK) {
                // case2
                w->color = RED;
                node = node->parent;
            } else if (w->left->color == BLACK) {
                // case3
                w->right->color = BLACK;
                w->color = RED;
                rbtree_left_rotate(T, w);
                w = node->parent->left;
            } else {
                // case4
                w->color = node->parent->color;
                node->parent->color = BLACK;
                w->left->color = BLACK;
                rbtree_right_rotate(T, node->parent);
                node = T->root;
            }
        }
    }
    node->color = BLACK;
}
```

## 5 小结
红黑树的代码实现到此结束，具体写起来还是很有趣的，也麻烦大家指出有什么谬误。

其实红黑树的本质是利用红黑性质保证其相对的平衡性，其中性质1-3都是定义性的性质，而性质4、5保证了红黑树没有一条路径会比其它路径长出两倍，也就保证了红黑树的相对平衡性，从而避免了搜索二叉树的退化问题。

另外红黑树的插入、删除再平衡时间都能保持在O(lg*n*)，且插入的翻转次数不超过2、删除的翻转次数不超过3，和严格的平衡二叉树AVL树相比，红黑树任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！！！