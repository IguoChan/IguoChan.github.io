---
title: 优先队列（二叉堆）（C语言实现）
date: 2021-12-05 17:30:50
tags: priority queue
categories: 数据结构
---

队列性质是先进先出，在[链表（C语言实现）](https://iguochan.github.io/2020/06/27/%E9%93%BE%E8%A1%A8/)中，我们介绍了使用链表实现队列的方法。对于有一些应用场景，我们并不希望完完全全地先进先出，而是希望不同的工作有不同的权重。这时候就需要用到优先队列了。

以下介绍了优先队列的C语言代码实现，[代码链接](https://github.com/IguoChan/data-structure/tree/main/queue)。

<!-- more -->

## 0 二叉堆

二叉堆是一棵完全填满的二叉树，有可能的例外在最底层，底层元素从左到右填入。这样的树称为完全二叉树。一棵高度为h的完全二叉树有2<sup>h</sup>到2<sup>h+1</sup>-1个节点，显然其是O(lg*n*)。因为完全二叉树很有规律，所以它可以用一个数组表示，而不需要指针。

二叉堆可以分为两种形式：**最大堆**和**最小堆**。

在最大堆中，最大堆性质：除了根节点，对于所有的节点i都要满足：`A[PARENT(i)] ≥ A[i]`；同理，最小堆性质：除了根节点，对于所有的节点i都要满足：`A[PARENT(i)] ≤ A[i]`。

在堆排序算法中，我们一般使用最大堆；在这里所要描述的优先队列中，最小堆通常用于构造优先队列。

## 1 声明

如下，我们声明优先队列的形式：
```c
#define MIN_PQ_SIZE 128
#define MIN_DATA INT_MAX

typedef int MyElement;

typedef struct heap pQueue_t;

typedef struct heap {
    int cap;
    int size;
    MyElement *elems;
} heap_t;
```

## 2 插入

为了保证二叉堆的性质，其插入操作的基本思想就是创建一个空穴，将其往上冒，最后摆在其合适的位置。如下：

![插入1](/img/二叉堆-插入1.png)
![插入2](/img/二叉堆-插入2.png)

其代码实现如下：

``` c
bool is_full(pQueue_t *H)
{
    if (!H) return false;

    if (H->size >= H->cap) return true;
    else return false;
}

bool is_empty(pQueue_t *H)
{
    if (!H) return true;

    if (H->size <= 0) return true;
    else return false;
}

int pQueue_insert(pQueue_t *H, MyElement x)
{
    int i;

    if (is_full(H)) return -1;

    for (i = ++H->size; H->elems[i/2] > x; i /= 2)
        H->elems[i] = H->elems[i/2];

    H->elems[i] = x;
}
```

## 3 删除
我们一般认为插入的值越小即权限越大，所以优先队列的出队列即获取并删除最小元。

我们采取的策略称之为**下滤**，即：
1. 我们取出最后一个元素；
2. 删除最小元后，我们将其较小的儿子放到空出的位置，同时空穴下滑了一层；
3. 重复以上操作直到空穴中正好可以填入最后一个元素。

![删除](/img/二叉堆-删除.png)

代码如下：
```c
MyElement get_and_delete_min(pQueue_t *H)
{
    int i, child;
    MyElement minElem, lastElem;

    if (is_empty(H)) return MIN_DATA;

    minElem = H->elems[1];
    lastElem = H->elems[H->size--];

    for (i = 1; i * 2 <= H->size; i = child) {
        child = i * 2;
        if (child != H->size && H->elems[child+1] < H->elems[child])
            child++;

        if (lastElem > H->elems[child])
            H->elems[i] = H->elems[child];
        else
            break;
    }
    H->elems[i] = lastElem;
    return minElem;
}
```

